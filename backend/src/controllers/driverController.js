import Driver from "../models/Driver.js";
import Booking from "../models/Booking.js";
import Review from "../models/Review.js";
import { createNotification } from "./notificationController.js";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import Payout from "../models/Payout.js";
import { serverLog } from "../utils/logger.js";
import { getIO } from "../utils/socketLogic.js";
import { calculateAndUpdatePenalty } from "./bookingController.js";

// ================= GENERATE JWT TOKEN FOR DRIVER =================
const generateDriverToken = (driverId) => {
  return jwt.sign(
    { driverId },
    process.env.JWT_SECRET,
    { expiresIn: "30d" }
  );
};

// ================= DRIVER REGISTRATION =================
export const registerDriver = async (req, res) => {
  try {
    const { name, mobile, password, vehicleNumber, vehicleModel, vehicleType, serviceType } = req.body;

    if (!name || !mobile || !password || !vehicleNumber || !vehicleModel) {
      return res.status(400).json({
        message: "All fields are required: name, mobile, password, vehicleNumber, vehicleModel"
      });
    }

    const existingDriver = await Driver.findOne({ mobile });
    if (existingDriver) {
      return res.status(400).json({
        message: "Mobile number already registered as a driver"
      });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const vType = vehicleType || "sedan";
    let sType = serviceType || "cab";

    // Restriction: Auto and Bike can only be 'cab' service type
    if (vType === 'auto' || vType === 'bike') {
      sType = 'cab';
    }

    const driver = await Driver.create({
      name,
      mobile,
      password: hashedPassword,
      vehicleNumber,
      vehicleModel,
      vehicleType: vType,
      serviceType: sType,
      available: true
    });

    const token = generateDriverToken(driver._id);

    res.status(201).json({
      message: "Driver registered successfully",
      token,
      driver: {
        id: driver._id,
        name: driver.name,
        mobile: driver.mobile,
        vehicleModel: driver.vehicleModel,
        vehicleNumber: driver.vehicleNumber,
        vehicleType: driver.vehicleType,
        serviceType: driver.serviceType,
        rating: driver.rating,
        available: driver.available,
        online: driver.online || false
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Driver registration failed",
      error: error.message
    });
  }
};

// ================= DRIVER LOGIN =================
export const loginDriver = async (req, res) => {
  try {
    const { mobile, password } = req.body;

    if (!mobile || !password) {
      return res.status(400).json({
        message: "Mobile and password are required"
      });
    }

    const driver = await Driver.findOne({ mobile });
    if (!driver) {
      return res.status(400).json({
        message: "Invalid mobile or password"
      });
    }

    const isMatch = await bcrypt.compare(password, driver.password);
    if (!isMatch) {
      return res.status(400).json({
        message: "Invalid mobile or password"
      });
    }

    const token = generateDriverToken(driver._id);

    res.json({
      message: "Login successful",
      token,
      driver: {
        id: driver._id,
        name: driver.name,
        mobile: driver.mobile,
        vehicleModel: driver.vehicleModel,
        vehicleNumber: driver.vehicleNumber,
        vehicleType: driver.vehicleType,
        serviceType: driver.serviceType,
        rating: driver.rating,
        available: driver.available,
        latitude: driver.latitude,
        longitude: driver.longitude,
        online: driver.online || false
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Driver login failed",
      error: error.message
    });
  }
};

// ================= GET NEARBY DRIVERS =================
export const getNearbyDrivers = async (req, res) => {
  try {
    const { latitude, longitude, serviceType } = req.query;

    const query = {
      available: true,
      online: true,
    };

    if (latitude && longitude) {
      query.location = {
        $near: {
          $geometry: {
            type: "Point",
            coordinates: [parseFloat(longitude), parseFloat(latitude)],
          },
          $maxDistance: 10000, // 10km
        },
      };
    }

    if (serviceType) {
      query.serviceType = serviceType;
    }

    const drivers = await Driver.find(query).select("-password");

    res.json({
      success: true,
      data: drivers.map(d => ({
        id: d._id,
        name: d.name,
        vehicleModel: d.vehicleModel,
        vehicleNumber: d.vehicleNumber,
        rating: d.rating,
        latitude: d.latitude,
        longitude: d.longitude,
        location: d.location
      }))
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to fetch drivers",
      error: error.message
    });
  }
};

// ================= GET DRIVER BY ID =================
export const getDriverById = async (req, res) => {
  try {
    const driver = await Driver.findById(req.params.id).select("-password");

    if (!driver) {
      return res.status(404).json({
        message: "Driver not found"
      });
    }

    res.json({
      driver: {
        id: driver._id,
        name: driver.name,
        mobile: driver.mobile,
        vehicleModel: driver.vehicleModel,
        vehicleNumber: driver.vehicleNumber,
        vehicleType: driver.vehicleType,
        serviceType: driver.serviceType,
        rating: driver.rating,
        available: driver.available,
        latitude: driver.latitude,
        longitude: driver.longitude
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to fetch driver",
      error: error.message
    });
  }
};

// ================= GET DRIVER PROFILE =================
export const getDriverProfile = async (req, res) => {
  try {
    const driver = await Driver.findById(req.driverId).select("-password");

    if (!driver) {
      return res.status(404).json({
        message: "Driver not found"
      });
    }

    // Get booking statistics
    const completedBookings = await Booking.countDocuments({
      driver: req.driverId,
      status: "completed"
    });
    const cancelledBookings = await Booking.countDocuments({
      driver: req.driverId,
      status: "cancelled"
    });

    // Calculate real rating
    const reviews = await Review.find({ driver: req.driverId });
    const avgRating = reviews.length > 0
      ? reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length
      : driver.rating; // Fallback to model rating

    res.json({
      driver: {
        id: driver._id,
        name: driver.name,
        mobile: driver.mobile,
        vehicleModel: driver.vehicleModel,
        vehicleNumber: driver.vehicleNumber,
        vehicleType: driver.vehicleType,
        serviceType: driver.serviceType,
        rating: Math.round(avgRating * 10) / 10,
        available: driver.available,
        latitude: driver.latitude,
        longitude: driver.longitude,
        createdAt: driver.createdAt,
        experienceYears: driver.experienceYears,
        vehicleColor: driver.vehicleColor,
        profileImage: driver.profileImage || "",
        documents: driver.documents,
        stats: {
          totalBookings: completedBookings + cancelledBookings,
          completedBookings: completedBookings,
          totalEarnings: driver.totalEarnings || 0,
          cancelledBookings
        }
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to fetch driver profile",
      error: error.message
    });
  }
};

// ================= UPDATE DRIVER PROFILE =================
export const updateDriverProfile = async (req, res) => {
  try {
    const { name, mobile, experienceYears } = req.body;
    const updateData = {};

    if (name) updateData.name = name;
    if (experienceYears !== undefined) updateData.experienceYears = experienceYears;
    if (mobile) {
      // Check if mobile is already taken by another driver
      const existingDriver = await Driver.findOne({
        mobile,
        _id: { $ne: req.driverId }
      });
      if (existingDriver) {
        return res.status(400).json({
          message: "Mobile number already in use"
        });
      }
      updateData.mobile = mobile;
    }

    const driver = await Driver.findByIdAndUpdate(
      req.driverId,
      updateData,
      { new: true }
    ).select("-password");

    if (!driver) {
      return res.status(404).json({
        message: "Driver not found"
      });
    }

    res.json({
      message: "Profile updated successfully",
      driver: {
        id: driver._id,
        name: driver.name,
        mobile: driver.mobile,
        vehicleModel: driver.vehicleModel,
        vehicleNumber: driver.vehicleNumber,
        vehicleType: driver.vehicleType,
        serviceType: driver.serviceType,
        rating: driver.rating,
        experienceYears: driver.experienceYears,
        available: driver.available
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to update driver profile",
      error: error.message
    });
  }
};

// ================= UPDATE VEHICLE DETAILS =================
export const updateVehicleDetails = async (req, res) => {
  try {
    const { vehicleNumber, vehicleModel, vehicleColor, vehicleType, serviceType } = req.body;

    const updateData = {};
    if (vehicleNumber) updateData.vehicleNumber = vehicleNumber;
    if (vehicleModel) updateData.vehicleModel = vehicleModel;
    if (vehicleColor) updateData.vehicleColor = vehicleColor;
    if (vehicleType) updateData.vehicleType = vehicleType;

    // Restriction: if vehicle is auto or bike, force serviceType to cab
    if (vehicleType === 'auto' || vehicleType === 'bike') {
      updateData.serviceType = 'cab';
    } else if (serviceType) {
      updateData.serviceType = serviceType;
    }

    const driver = await Driver.findByIdAndUpdate(
      req.driverId,
      updateData,
      { new: true }
    ).select("-password");

    if (!driver) {
      return res.status(404).json({
        message: "Driver not found"
      });
    }

    res.json({
      message: "Vehicle details updated successfully",
      driver: {
        id: driver._id,
        name: driver.name,
        vehicleModel: driver.vehicleModel,
        vehicleNumber: driver.vehicleNumber,
        vehicleColor: driver.vehicleColor,
        vehicleType: driver.vehicleType,
        serviceType: driver.serviceType
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to update vehicle details",
      error: error.message
    });
  }
};

// ================= UPDATE DRIVER DOCUMENTS =================
export const updateDocuments = async (req, res) => {
  try {
    const { license, insurance, registration } = req.body;
    const updateData = {};

    if (license) updateData['documents.license'] = license;
    if (insurance) updateData['documents.insurance'] = insurance;
    if (registration) updateData['documents.registration'] = registration;

    const driver = await Driver.findByIdAndUpdate(
      req.driverId,
      { $set: updateData },
      { new: true }
    ).select("-password");

    if (!driver) {
      return res.status(404).json({
        message: "Driver not found"
      });
    }

    res.json({
      message: "Documents updated successfully",
      documents: driver.documents
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to update documents",
      error: error.message
    });
  }
};

// Helper for proximity detection (Haversine distance in meters)
const getDistanceInMeters = (lat1, lon1, lat2, lon2) => {
  const R = 6371000; // Radius of the earth in meters
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
};

// ================= UPDATE DRIVER LOCATION =================
export const updateDriverLocation = async (req, res) => {
  try {
    const { latitude, longitude } = req.body;

    if (latitude === undefined || longitude === undefined) {
      return res.status(400).json({
        message: "Latitude and longitude are required"
      });
    }

    const driver = await Driver.findByIdAndUpdate(
      req.driverId,
      {
        latitude,
        longitude,
        location: {
          type: "Point",
          coordinates: [longitude, latitude]
        },
        lastLocationUpdate: new Date()
      },
      { new: true }
    ).select("-password");

    if (!driver) {
      return res.status(404).json({
        message: "Driver not found"
      });
    }

    res.json({
      message: "Location updated successfully",
      driver: {
        id: driver._id,
        latitude: driver.latitude,
        longitude: driver.longitude,
        location: driver.location
      }
    });

    // Broadcast update if there's an active booking
    try {
      if (driver.currentBooking) {
        const io = getIO();
        io.to(driver.currentBooking.toString()).emit("driverLocationUpdate", {
          bookingId: driver.currentBooking,
          latitude: latitude,
          longitude: longitude
        });

        // Also broadcast to user room for safety
        const activeBooking = await Booking.findById(driver.currentBooking);
        if (activeBooking) {
          io.to(activeBooking.user.toString()).emit("driverLocationUpdate", {
            bookingId: activeBooking._id,
            latitude: latitude,
            longitude: longitude
          });

          // Proximity detection: if within 100m of pickup and notification not yet sent
          if (activeBooking.status === "accepted" && !activeBooking.nearbyNotificationSent) {
            const distance = getDistanceInMeters(
              latitude, longitude,
              activeBooking.pickupLatitude, activeBooking.pickupLongitude
            );

            if (distance <= 100) {
              activeBooking.nearbyNotificationSent = true;
              await activeBooking.save();

              await createNotification({
                userId: activeBooking.user,
                title: "Driver is Nearby! ðŸ“",
                body: "Your driver is less than 100m away. Please get ready for your ride.",
                type: "ride_nearby",
                bookingId: activeBooking._id
              });
              serverLog(`Proximity alert sent: Driver ${req.driverId} is within ${Math.round(distance)}m of user ${activeBooking.user}`);
            }
          }
        }
      } else {
        // Fallback for logic safety
        const activeBooking = await Booking.findOne({
          driver: req.driverId,
          status: { $in: ["accepted", "arrived", "started"] }
        });
        if (activeBooking) {
          const io = getIO();
          io.to(activeBooking.user.toString()).emit("driverLocationUpdate", {
            bookingId: activeBooking._id,
            latitude: latitude,
            longitude: longitude
          });
        }
      }
    } catch (socketError) {
      serverLog(`Socket broadcast error: ${socketError.message}`);
    }
  } catch (error) {
    res.status(500).json({
      message: "Failed to update location",
      error: error.message
    });
  }
};

// ================= TOGGLE DRIVER AVAILABILITY =================
export const toggleAvailability = async (req, res) => {
  try {
    const driver = await Driver.findById(req.driverId);

    if (!driver) {
      return res.status(404).json({
        message: "Driver not found"
      });
    }

    driver.available = !driver.available;
    await driver.save();

    res.json({
      message: driver.available ? "Driver is now available" : "Driver is now unavailable",
      available: driver.available
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to toggle availability",
      error: error.message
    });
  }
};

// ================= TOGGLE DRIVER ONLINE STATUS =================
export const toggleOnlineStatus = async (req, res) => {
  try {
    const driver = await Driver.findById(req.driverId);

    if (!driver) {
      return res.status(404).json({
        message: "Driver not found"
      });
    }

    const now = new Date();

    if (driver.online) {
      // Transitioning from ONLINE to OFFLINE
      if (driver.lastOnlineToggle) {
        const diffMs = now - driver.lastOnlineToggle;
        const diffMins = Math.floor(diffMs / 60000);
        driver.onlineTime = (driver.onlineTime || 0) + diffMins;
      }
      driver.online = false;
      driver.available = false;
      driver.lastOnlineToggle = now;
    } else {
      // Transitioning from OFFLINE to ONLINE
      driver.online = true;
      driver.lastOnlineToggle = now;
    }

    await driver.save();

    res.json({
      message: driver.online ? "Driver is now online" : "Driver is now offline",
      online: driver.online,
      available: driver.available,
      onlineTime: driver.onlineTime
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to toggle online status",
      error: error.message
    });
  }
};

// ================= GET AVAILABLE BOOKINGS =================
export const getAvailableBookings = async (req, res) => {
  try {
    // Get bookings that are pending or need a driver
    const bookings = await Booking.find({
      status: { $in: ["pending", "driver_assigned"] },
      driver: { $in: [null, req.driverId] }
    })
      .populate("user", "name mobile")
      .sort({ createdAt: -1 })
      .limit(50);

    res.json({
      bookings: bookings.map(booking => ({
        id: booking._id,
        pickupLocation: booking.pickupLocation,
        pickupLatitude: booking.pickupLatitude,
        pickupLongitude: booking.pickupLongitude,
        dropLocation: booking.dropLocation,
        dropLatitude: booking.dropLatitude,
        dropLongitude: booking.dropLongitude,
        rideType: booking.rideType,
        bookingType: booking.bookingType,
        status: booking.status,
        fare: booking.fare,
        distance: booking.distance,
        scheduledDate: booking.scheduledDate,
        user: booking.user
      }))
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to fetch available bookings",
      error: error.message
    });
  }
};

// ================= GET CURRENT BOOKING =================
export const getCurrentBooking = async (req, res) => {
  try {
    const driver = await Driver.findById(req.driverId);

    let booking;
    if (driver && driver.currentBooking) {
      booking = await Booking.findById(driver.currentBooking)
        .populate("user", "name mobile profileImage")
        .populate("driver", "name mobile vehicleModel vehicleNumber rating latitude longitude location");
    }

    // Fallback if currentBooking is missing or stale - includes all active statuses
    if (!booking) {
      booking = await Booking.findOne({
        driver: req.driverId,
        status: { $in: ["accepted", "driver_assigned", "arrived", "started", "waiting", "return_ride_started"] }
      })
        .sort({ createdAt: -1 })
        .populate("user", "name mobile profileImage")
        .populate("driver", "name mobile vehicleModel vehicleNumber rating latitude longitude location");

      if (booking) {
        await Driver.findByIdAndUpdate(req.driverId, { currentBooking: booking._id });
      }
    }

    if (booking && (booking.status === "cancelled" || booking.status === "completed")) {
      await Driver.findByIdAndUpdate(req.driverId, { currentBooking: null, available: true });
      return res.status(404).json({ message: "No active booking found" });
    }

    if (!booking) {
      return res.status(404).json({ message: "No active booking found" });
    }

    // Trigger penalty calculation if driver is in waiting phase
    if (booking.waitingStartedAt) {
      await calculateAndUpdatePenalty(booking);
    }

    res.json({
      booking: {
        id: booking._id,
        pickupLocation: booking.pickupLocation,
        pickupLatitude: booking.pickupLatitude,
        pickupLongitude: booking.pickupLongitude,
        dropLocation: booking.dropLocation,
        dropLatitude: booking.dropLatitude,
        dropLongitude: booking.dropLongitude,
        rideType: booking.rideType,
        status: booking.status,
        otp: booking.otp,
        fare: booking.fare,
        distance: booking.distance,
        paymentMethod: booking.paymentMethod,
        user: booking.user,
        driver: booking.driver,
        hasReturnTrip: booking.hasReturnTrip,
        returnTripFare: booking.returnTripFare,
        penaltyApplied: booking.penaltyApplied || 0,
        waitingStartedAt: booking.waitingStartedAt,
        waitingLimit: booking.waitingLimit,
        createdAt: booking.createdAt
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to fetch current booking",
      error: error.message
    });
  }
};


// ================= ACCEPT BOOKING =================
export const acceptBooking = async (req, res) => {
  try {
    const booking = await Booking.findById(req.params.id);

    if (!booking) {
      return res.status(404).json({
        message: "Booking not found"
      });
    }

    if (booking.status !== "pending" && booking.status !== "driver_assigned") {
      return res.status(400).json({
        message: "This booking cannot be accepted"
      });
    }

    // Prevent accepting if already has an active ride
    const driver = await Driver.findById(req.driverId);
    if (driver.currentBooking) {
      const activeCheck = await Booking.findById(driver.currentBooking);
      if (activeCheck && !["completed", "cancelled"].includes(activeCheck.status)) {
        return res.status(400).json({
          message: "You already have an active ride"
        });
      }
    }

    // Update booking with driver
    booking.driver = req.driverId;
    booking.status = "accepted";
    await booking.save();
    serverLog(`Booking ${booking._id} accepted by driver ${req.driverId}`);

    // Make driver unavailable and track current ride
    driver.available = false;
    driver.currentBooking = booking._id;
    await driver.save();

    const populatedBooking = await Booking.findById(booking._id)
      .populate("user", "name mobile profileImage")
      .populate("driver", "name mobile vehicleModel vehicleNumber rating vehicleType profileImage latitude longitude location");

    // NOTIFY USER via Socket
    const { getIO: ioGetter } = await import("../utils/socketLogic.js");
    const io = ioGetter();
    io.to(populatedBooking.user._id.toString()).emit("rideAccepted", {
      booking: {
        id: populatedBooking._id,
        status: populatedBooking.status,
        driver: {
          name: populatedBooking.driver.name,
          mobile: populatedBooking.driver.mobile,
          vehicleModel: populatedBooking.driver.vehicleModel,
          vehicleNumber: populatedBooking.driver.vehicleNumber,
          vehicleType: populatedBooking.driver.vehicleType,
          rating: populatedBooking.driver.rating,
          profileImage: populatedBooking.driver.profileImage
        }
      }
    });

    // Notify other drivers to hide this request
    io.emit("rideRequestCancelled", {
      bookingId: populatedBooking._id.toString()
    });

    // Create persistent notification for user
    await createNotification({
      userId: populatedBooking.user._id,
      title: "Ride Accepted! ðŸš—",
      body: `Driver ${populatedBooking.driver.name} has accepted your ride. They are on their way!`,
      type: "ride_accepted",
      bookingId: populatedBooking._id
    });

    res.json({
      message: "Booking accepted successfully",
      booking: {
        id: populatedBooking._id,
        pickupLocation: populatedBooking.pickupLocation,
        pickupLatitude: populatedBooking.pickupLatitude,
        pickupLongitude: populatedBooking.pickupLongitude,
        dropLocation: populatedBooking.dropLocation,
        dropLatitude: populatedBooking.dropLatitude,
        dropLongitude: populatedBooking.dropLongitude,
        status: populatedBooking.status,
        otp: populatedBooking.otp,
        fare: populatedBooking.fare,
        user: populatedBooking.user,
        driver: populatedBooking.driver
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to accept booking",
      error: error.message
    });
  }
};

// ================= REJECT BOOKING =================
export const rejectBooking = async (req, res) => {
  try {
    const booking = await Booking.findById(req.params.id);

    if (!booking) {
      return res.status(404).json({
        message: "Booking not found"
      });
    }

    if (booking.driver && booking.driver.toString() !== req.driverId) {
      return res.status(403).json({
        message: "You cannot reject this booking"
      });
    }

    // Reset driver assignment
    if (booking.driver && booking.driver.toString() === req.driverId) {
      booking.driver = null;
      booking.status = "pending";
      await booking.save();

      // Make driver available again
      await Driver.findByIdAndUpdate(req.driverId, { available: true });
    }

    res.json({
      message: "Booking rejected successfully"
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to reject booking",
      error: error.message
    });
  }
};

// ================= UPDATE BOOKING STATUS =================
export const updateBookingStatus = async (req, res) => {
  try {
    const { status, fare, distance } = req.body;
    const booking = await Booking.findById(req.params.id);

    if (!booking) {
      return res.status(404).json({
        message: "Booking not found"
      });
    }

    if (booking.driver && booking.driver.toString() !== req.driverId) {
      return res.status(403).json({
        message: "You are not authorized to update this booking"
      });
    }

    // Validate status transitions
    const validTransitions = {
      "accepted": ["arrived"],
      "arrived": ["started"],
      "started": ["completed", "waiting"],
      "waiting": ["return_ride_started", "completed"],
      "return_ride_started": ["completed"],
      "completed": [],
      "cancelled": []
    };

    if (!validTransitions[booking.status]?.includes(status)) {
      return res.status(400).json({
        message: `Cannot transition from ${booking.status} to ${status}`
      });
    }

    booking.status = status;

    if (status === "arrived") {
      booking.driverArrivedAt = new Date();
    }

    if (status === "completed") {
      // Preserve base fare, incoming fare is treated as totalFare
      if (!booking.fare || booking.fare === 0) {
        booking.fare = fare || 0;
      }
      booking.totalFare = fare || (booking.fare + (booking.returnTripFare || 0) + (booking.penaltyApplied || 0));
      booking.distance = distance || booking.distance || 0;
      booking.paymentStatus = "pending";

      // Make driver available again
      await Driver.findByIdAndUpdate(req.driverId, { available: true });
    }

    // CRITICAL: Save to DB before emitting socket events to avoid race conditions on client refresh
    await booking.save();
    serverLog(`Booking status successfully updated and saved: ${status} for booking ${booking._id}`);

    // Emit socket events for real-time updates
    try {
      const io = getIO();
      const userRoom = booking.user.toString();

      // Unified event for status update
      io.to(userRoom).emit("rideStatusUpdate", {
        bookingId: booking._id.toString(),
        status: status,
        message: `Ride status updated to ${status}`
      });
      serverLog(`rideStatusUpdate [${status}] emitted to room ${userRoom}`);

      // Special event and message for Arrival
      if (status === "arrived") {
        io.to(userRoom).emit("driverArrived", {
          bookingId: booking._id.toString(),
          message: "Your driver has arrived at the pickup location!"
        });
        serverLog(`driverArrived specific event emitted to room ${userRoom}`);

        // Create persistent notification
        await createNotification({
          userId: booking.user,
          title: "Driver Arrived! ðŸš—",
          body: "Your driver has arrived at the pickup location. Please proceed to the vehicle.",
          type: "ride_arrived",
          bookingId: booking._id
        });
      }

      if (status === "completed") {
        await createNotification({
          userId: booking.user,
          title: "Ride Completed! âœ…",
          body: `Your ride is completed. Final fare: â‚¹${booking.fare}. Hope you had a great trip!`,
          type: "ride_completed",
          bookingId: booking._id
        });
      }
    } catch (socketError) {
      serverLog(`Socket notification error: ${socketError.message}`);
    }

    const populatedBooking = await Booking.findById(booking._id)
      .populate("user", "name mobile")
      .populate("driver", "name mobile vehicleModel vehicleNumber rating");

    res.json({
      message: `Booking status updated to ${status}`,
      booking: {
        id: populatedBooking._id,
        pickupLocation: populatedBooking.pickupLocation,
        dropLocation: populatedBooking.dropLocation,
        status: populatedBooking.status,
        fare: populatedBooking.fare,
        distance: populatedBooking.distance,
        paymentStatus: populatedBooking.paymentStatus,
        user: populatedBooking.user,
        driver: populatedBooking.driver
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to update booking status",
      error: error.message
    });
  }
};

// ================= GET DRIVER BOOKING HISTORY =================
export const getDriverHistory = async (req, res) => {
  try {
    const { page = 1, limit = 20 } = req.query;

    const bookings = await Booking.find({ driver: req.driverId })
      .populate("user", "name mobile")
      .sort({ createdAt: -1 })
      .limit(limit * 1)
      .skip((page - 1) * limit);

    const total = await Booking.countDocuments({ driver: req.driverId });

    res.json({
      bookings: bookings.map(booking => ({
        id: booking._id,
        pickupLocation: booking.pickupLocation,
        dropLocation: booking.dropLocation,
        rideType: booking.rideType,
        status: booking.status,
        fare: booking.fare,
        distance: booking.distance,
        paymentStatus: booking.paymentStatus,
        user: booking.user,
        rating: booking.rating || 0,
        feedback: booking.feedback || "",
        createdAt: booking.createdAt
      })),
      pagination: {
        total,
        page: parseInt(page),
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to fetch booking history",
      error: error.message
    });
  }
};

// ================= GET DRIVER EARNINGS =================
export const getDriverEarnings = async (req, res) => {
  try {
    const { period = "week" } = req.query; // day, week, month, all

    let startDate = new Date();
    switch (period) {
      case "day":
        startDate.setHours(0, 0, 0, 0);
        break;
      case "week":
        startDate.setDate(startDate.getDate() - 7);
        break;
      case "month":
        startDate.setMonth(startDate.getMonth() - 1);
        break;
      case "all":
        startDate = new Date(0);
        break;
    }

    const completedBookings = await Booking.find({
      driver: req.driverId,
      status: "completed",
      createdAt: { $gte: startDate }
    });

    const totalEarnings = completedBookings.reduce((sum, booking) => sum + (booking.fare || 0), 0);
    const totalTrips = completedBookings.length;
    const averageFare = totalTrips > 0 ? totalEarnings / totalTrips : 0;

    // Calculate today's earnings
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayEarnings = completedBookings
      .filter(booking => new Date(booking.createdAt) >= today)
      .reduce((sum, booking) => sum + (booking.fare || 0), 0);

    // Fetch payouts/activities for history
    const payouts = await Payout.find({
      driver: req.driverId,
      createdAt: { $gte: startDate }
    }).sort({ createdAt: -1 });

    const driver = await Driver.findById(req.driverId);
    const onlineHours = Math.round(((driver.onlineTime || 0) / 60) * 10) / 10;

    res.json({
      earnings: {
        totalEarnings: driver.totalEarnings || 0,
        totalTrips: driver.totalTrips || 0,
        averageFare: Math.round(averageFare * 100) / 100,
        todayEarnings,
        onlineHours,
        period,
        activities: payouts.map(p => ({
          id: p._id,
          type: "payout",
          amount: p.amount,
          status: p.status,
          method: p.paymentMethod,
          date: p.createdAt
        }))
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to fetch earnings",
      error: error.message
    });
  }
};

// ================= GET DRIVER REVIEWS =================
export const getDriverReviews = async (req, res) => {
  try {
    const { page = 1, limit = 10 } = req.query;

    const driver = await Driver.findById(req.driverId);

    if (!driver) {
      return res.status(404).json({
        message: "Driver not found"
      });
    }

    const reviews = await Review.find({ driver: req.driverId })
      .sort({ createdAt: -1 })
      .skip((page - 1) * limit)
      .limit(parseInt(limit))
      .populate("user", "name profileImage");

    const totalReviews = await Review.countDocuments({ driver: req.driverId });

    const formattedReviews = reviews.map(review => ({
      id: review._id,
      userName: review.user ? review.user.name : "Anonymous",
      userImage: review.user ? review.user.profileImage : null,
      rating: review.rating,
      comment: review.comment,
      createdAt: review.createdAt
    }));

    res.json({
      reviews: formattedReviews,
      averageRating: driver.rating,
      totalReviews: totalReviews,
      pagination: {
        page: parseInt(page),
        pages: Math.ceil(totalReviews / limit)
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to fetch reviews",
      error: error.message
    });
  }
};

// ================= VERIFY RIDE OTP =================
export const verifyRideOtp = async (req, res) => {
  try {
    const { otp } = req.body;
    const { id } = req.params;

    serverLog(`OTP Verification Attempt: Booking ${id}, OTP provided: ${otp}`);

    const booking = await Booking.findById(id);

    if (!booking) {
      serverLog(`OTP Verification Failed: Booking ${id} not found`);
      return res.status(404).json({
        message: "Booking not found"
      });
    }

    // Safety check for driver
    if (booking.driver.toString() !== req.driverId.toString()) {
      serverLog(`OTP Verification Failed: Driver mismatch. Request: ${req.driverId}, Booking: ${booking.driver}`);
      return res.status(403).json({
        message: "Not authorized to verify this ride"
      });
    }

    if (String(booking.otp) !== String(otp)) {
      serverLog(`OTP Verification Failed: Mismatch. Expected: ${booking.otp}, Received: ${otp}`);
      return res.status(400).json({
        message: "Invalid OTP"
      });
    }

    booking.status = "started";
    booking.rideStartedAt = new Date();
    await booking.save();

    // Notify user that ride has started
    try {
      const io = getIO();
      io.to(booking.user.toString()).emit("rideStatusUpdate", {
        bookingId: booking._id.toString(),
        status: "started",
        message: "Your ride has started!"
      });

      // Create persistent notification
      await createNotification({
        userId: booking.user,
        title: "Ride Started! ðŸ›£ï¸",
        body: "Your ride has started. Have a safe journey!",
        type: "ride_started",
        bookingId: booking._id
      });

      // Suggest Return Trip Offer (60% OFF)
      io.to(booking.user.toString()).emit("suggestReturnTrip", {
        bookingId: booking._id.toString(),
        message: "Enjoy 60% OFF on your return trip! Accept now to book your return."
      });

      // Persistent notification for the offer
      await createNotification({
        userId: booking.user,
        title: "Limited Offer: 60% OFF Return Trip! ðŸ“‰",
        body: "Book your return trip now and save 60%. Offer valid for this ride only!",
        type: "ride_accepted", // Using ride_accepted type for highlighting
        bookingId: booking._id
      });
    } catch (socketError) {
      serverLog(`Socket notification error: ${socketError.message}`);
    }

    res.json({
      message: "OTP verified, ride started",
      booking: {
        id: booking._id,
        status: booking.status
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to verify OTP",
      error: error.message
    });
  }
};

// ================= COMPLETE RIDE =================
export const completeRide = async (req, res) => {
  try {
    const { fare, distance } = req.body;
    const booking = await Booking.findOne({
      driver: req.driverId,
      status: { $in: ["started", "waiting", "return_ride_started"] }
    });

    if (!booking) {
      return res.status(404).json({
        message: "No active ride found to complete"
      });
    }

    booking.status = "completed";
    // Preserve base fare, use incoming fare as totalFare
    if (!booking.fare || booking.fare === 0) {
      booking.fare = fare || 0;
    }
    booking.totalFare = fare || (booking.fare + (booking.returnTripFare || 0) + (booking.penaltyApplied || 0));
    booking.distance = distance || booking.distance || 0;
    booking.paymentStatus = "pending";
    booking.rideCompletedAt = new Date();
    await booking.save();

    // Clear driver's active booking
    await Driver.findByIdAndUpdate(req.driverId, {
      currentBooking: null,
      available: true
    });

    // Notify User via Socket
    try {
      const io = getIO();
      const userRoom = booking.user.toString();
      io.to(userRoom).emit("rideStatusUpdate", {
        bookingId: booking._id.toString(),
        status: "completed",
        fare: booking.fare,
        totalFare: booking.totalFare,
        distance: booking.distance,
        message: "Ride completed"
      });

      // Create persistent notification
      await createNotification({
        userId: booking.user,
        title: "Ride Completed! âœ…",
        body: `Your ride is completed. Final fare: â‚¹${booking.fare}. Hope you had a great trip!`,
        type: "ride_completed",
        bookingId: booking._id
      });
    } catch (socketError) {
      serverLog(`Socket notification error: ${socketError.message}`);
    }

    // Make driver available again and update statistics
    await Driver.findByIdAndUpdate(req.driverId, {
      available: true,
      $inc: {
        totalTrips: 1,
        totalEarnings: booking.fare || 0
      }
    });

    res.json({
      message: "Ride completed successfully",
      booking: {
        id: booking._id,
        status: booking.status,
        fare: booking.fare,
        distance: booking.distance,
        paymentStatus: booking.paymentStatus
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to complete ride",
      error: error.message
    });
  }
};

// ================= CANCEL BOOKING (DRIVER) =================
export const cancelBooking = async (req, res) => {
  try {
    const { reason } = req.body;
    const booking = await Booking.findOne({
      _id: req.params.id,
      driver: req.driverId,
      status: { $nin: ["completed", "cancelled"] }
    });

    if (!booking) {
      return res.status(404).json({
        message: "Booking not found or cannot be cancelled"
      });
    }

    booking.status = "cancelled";
    booking.cancellationReason = reason || "Cancelled by driver";
    await booking.save();

    // Make driver available again and clear current ride
    await Driver.findByIdAndUpdate(req.driverId, {
      available: true,
      currentBooking: null
    });

    // Notify User
    try {
      const { getIO } = await import("../utils/socketLogic.js");
      getIO().to(booking.user.toString()).emit("bookingCancelledByDriver", {
        bookingId: booking._id,
        message: "The driver has cancelled this ride."
      });

      // Create persistent notification
      await createNotification({
        userId: booking.user,
        title: "Ride Cancelled âŒ",
        body: `The driver has cancelled the ride. Reason: ${booking.cancellationReason}`,
        type: "ride_cancelled",
        bookingId: booking._id
      });
    } catch (socketError) {
      console.error(`Socket notification error: ${socketError.message}`);
    }

    res.json({
      message: "Booking cancelled successfully",
      booking: {
        id: booking._id,
        status: booking.status,
        cancellationReason: booking.cancellationReason
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to cancel booking",
      error: error.message
    });
  }
};

// ================= GET DASHBOARD STATS =================
export const getDriverDashboard = async (req, res) => {
  try {
    const driver = await Driver.findById(req.driverId).select("-password");

    if (!driver) {
      return res.status(404).json({
        message: "Driver not found"
      });
    }

    // Get today's date
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Today's completed trips
    const todayTrips = await Booking.countDocuments({
      driver: req.driverId,
      status: "completed",
      createdAt: { $gte: today }
    });

    // Calculate real average rating for dashboard
    const allReviews = await Review.find({ driver: req.driverId });
    const avgRatingDash = allReviews.length > 0
      ? allReviews.reduce((sum, r) => sum + r.rating, 0) / allReviews.length
      : driver.rating;

    // Today's earnings
    const todayBookings = await Booking.find({
      driver: req.driverId,
      status: "completed",
      createdAt: { $gte: today }
    });
    const todayEarnings = todayBookings.reduce((sum, b) => sum + (b.fare || 0), 0);

    // Total completed trips
    const totalTrips = await Booking.countDocuments({
      driver: req.driverId,
      status: "completed"
    });

    // Pending bookings count
    const pendingBookings = await Booking.countDocuments({
      status: "pending"
    });

    // Current booking using explicit tracking
    let currentBooking = null;
    if (driver.currentBooking) {
      currentBooking = await Booking.findById(driver.currentBooking)
        .populate("user", "name mobile");
    }

    // Fallback only if needed (safety net)
    if (!currentBooking) {
      currentBooking = await Booking.findOne({
        driver: req.driverId,
        status: { $in: ["accepted", "driver_assigned", "arrived", "started"] }
      }).sort({ createdAt: -1 }).populate("user", "name mobile");

      // If found via fallback, sync it to driver.currentBooking
      if (currentBooking) {
        await Driver.findByIdAndUpdate(req.driverId, { currentBooking: currentBooking._id });
      }
    }

    // Double-check: if booking exists but is cancelled/completed, clear it
    if (currentBooking && (currentBooking.status === "cancelled" || currentBooking.status === "completed")) {
      await Driver.findByIdAndUpdate(req.driverId, { currentBooking: null, available: true });
      currentBooking = null;
    }

    res.json({
      dashboard: {
        driver: {
          id: driver._id,
          name: driver.name,
          rating: Math.round(avgRatingDash * 10) / 10,
          available: driver.available,
          online: driver.online || false,
          vehicleType: driver.vehicleType,
          serviceType: driver.serviceType,
          profileImage: driver.profileImage || ""
        },
        stats: {
          todayTrips,
          todayEarnings,
          totalTrips,
          totalEarnings: driver.totalEarnings || 0,
          pendingBookings,
          rating: Math.round(avgRatingDash * 10) / 10
        },
        currentBooking: currentBooking ? {
          id: currentBooking._id,
          pickupLocation: currentBooking.pickupLocation,
          dropLocation: currentBooking.dropLocation,
          status: currentBooking.status,
          user: currentBooking.user
        } : null
      }
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to fetch dashboard",
      error: error.message
    });
  }
};

// ================= CHANGE PASSWORD =================
export const changePassword = async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;

    if (!currentPassword || !newPassword) {
      return res.status(400).json({
        message: "Current password and new password are required"
      });
    }

    const driver = await Driver.findById(req.driverId);

    if (!driver) {
      return res.status(404).json({
        message: "Driver not found"
      });
    }

    const isMatch = await bcrypt.compare(currentPassword, driver.password);
    if (!isMatch) {
      return res.status(400).json({
        message: "Current password is incorrect"
      });
    }

    driver.password = await bcrypt.hash(newPassword, 10);
    await driver.save();

    res.json({
      message: "Password changed successfully"
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to change password",
      error: error.message
    });
  }
};

// ================= LOGOUT DRIVER =================
export const logoutDriver = async (req, res) => {
  try {
    // In a real app, you might want to blacklist the token
    // For now, we just return success
    // Make driver unavailable on logout
    await Driver.findByIdAndUpdate(req.driverId, { available: false });

    res.json({
      message: "Logout successful"
    });
  } catch (error) {
    res.status(500).json({
      message: "Logout failed",
      error: error.message
    });
  }
};

// ================= REQUEST PAYOUT =================
export const requestPayout = async (req, res) => {
  try {
    const { amount } = req.body;

    if (!amount || amount <= 0) {
      return res.status(400).json({
        message: "Invalid payout amount"
      });
    }

    const driver = await Driver.findById(req.driverId);
    if (!driver) {
      return res.status(404).json({
        message: "Driver not found"
      });
    }

    if (amount > (driver.totalEarnings || 0)) {
      return res.status(400).json({
        message: "Insufficient balance"
      });
    }

    const payout = await Payout.create({
      driver: req.driverId,
      amount,
      status: "pending"
    });

    res.status(201).json({
      message: "Payout request submitted successfully",
      payout
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to submit payout request",
      error: error.message
    });
  }
};

// ================= UPDATE PROFILE IMAGE =================
export const updateProfileImage = async (req, res) => {
  try {
    const { profileImage } = req.body;

    if (!profileImage) {
      return res.status(400).json({
        message: "Profile image is required"
      });
    }

    const driver = await Driver.findByIdAndUpdate(
      req.driverId,
      { profileImage },
      { new: true }
    );

    if (!driver) {
      return res.status(404).json({
        message: "Driver not found"
      });
    }

    res.json({
      message: "Profile image updated successfully",
      profileImage: driver.profileImage
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to update profile image",
      error: error.message
    });
  }
};

// ================= FORGOT PASSWORD =================
export const forgotPassword = async (req, res) => {
  try {
    const { mobile } = req.body;

    if (!mobile) {
      return res.status(400).json({
        message: "Mobile number is required"
      });
    }

    const driver = await Driver.findOne({ mobile });

    if (!driver) {
      return res.status(404).json({
        message: "Driver with this mobile number not found"
      });
    }

    // In a real app, generate a random OTP and send via SMS
    // For now, we'll use a mock OTP: 1234
    const otp = "1234";

    res.json({
      message: "OTP sent successfully (MOCK: 1234)",
      otp: otp // Returning OTP for demo purposes
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to send OTP",
      error: error.message
    });
  }
};

// ================= RESET PASSWORD =================
export const resetPassword = async (req, res) => {
  try {
    const { mobile, otp, newPassword } = req.body;

    if (!mobile || !otp || !newPassword) {
      return res.status(400).json({
        message: "Mobile, OTP and new password are required"
      });
    }

    // Verify OTP (mock verification)
    if (otp !== "1234") {
      return res.status(400).json({
        message: "Invalid OTP"
      });
    }

    const driver = await Driver.findOne({ mobile });

    if (!driver) {
      return res.status(404).json({
        message: "Driver not found"
      });
    }

    const hashedPassword = await bcrypt.hash(newPassword, 10);
    driver.password = hashedPassword;
    await driver.save();

    res.json({
      message: "Password reset successfully"
    });
  } catch (error) {
    res.status(500).json({
      message: "Failed to reset password",
      error: error.message
    });
  }
};
